
USING_YOSYS_NAMESPACE

using namespace MV_BACKEND; 

const pool<string> MV_BACKEND::mv_keywords() {
    static const pool<string> res = {
        // TODO: fill in mv keywords 
    };
    return res;
}

// initialize variables
bool noglitch;

struct MvBackend : public Backend {
    Mvbackend() : Backend("mv", "generate MV file from RTLIL design for verification") { }
    void help() override {
        // TODO: add help message
        log("\n");
        log("    write_mv [options] [filename]\n");
        log("\n");
        log("Generate MV file from RTLIL design for verification.\n");
        log("\n");
        log("    -noglitch\n");
        log("        Disable glitch modeling when generating MV file.\n");
        log("\n");

    }
    void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Design *design) override {
        log_header(design, "Executing MV backend.\n");

        // TODO: Process arguments
        // EXTEND: Arguments 

        noglitch = false;


        size_t argidx; 
        for (argidx = 1; argidx < args.size(); argidx++) {
            std::string arg = args[argidx];
            if (arg == "-noglitch") {
                noglitch = true;
                continue;
            }
            cmd_error(args, argidx, "Unknown option or option in arguments.");
        }
        extra_args(f, filename, args, argidx); // write file content to ostream f 
        
        *f << stringf("/* Generated by Yosys_expr based on %s */\n", yosys_maybe_version());

        // TODO: Implement MV backend logic

        // first get simcells.v, transform into expr formation 
        // see proc expr

        /*
        std::string verilog_frontend = "verilog -nooverwrite -noblackbox";

        RTLIL::Design *simcells_lib = new RTLIL::Design; 

        Frontend::frontend_call(simcells_lib, nullptr, "+/simcells.v", verilog_frontend); // read share/simcells.v

        // print the design 
        log("===================== Print simcells ======================\n");
        dict<RTLIL::IdString, RTLIL::Module*> modules_of_simcells = simcells_lib->modules_;
        for(std::pair<const RTLIL::IdString, RTLIL::Module*>module_pair : modules_of_simcells) {
            log("Module name: %s.\n", module_pair.first.c_str());
            dict<RTLIL::IdString, RTLIL::Wire *> wires_of_module = module_pair.second->wires_;
            dict<RTLIL::IdString, RTLIL::Cell *> cells_of_module = module_pair.second->cells_;
            log("  Wires:\n");
            for(std::pair<const RTLIL::IdString, RTLIL::Wire *>wire_pair : wires_of_module) {
                log("    %s\n", wire_pair.first.c_str());
            }
            log("  Cells:\n");
            for(std::pair<const RTLIL::IdString, RTLIL::Cell *>cell_pair : cells_of_module) {
                dict<RTLIL::IdString, RTLIL::SigSpec> conn_of_cell = cell_pair.second->connections_;
                // parameters
                log("    %s: type %s, conn ", cell_pair.first.c_str(), cell_pair.second->type.c_str());
                for(std::pair<const RTLIL::IdString, RTLIL::SigSpec>conn_pair : conn_of_cell) {
                    log("%s ", conn_pair.first.c_str());
                }
                log("\n");
            }
        }
        log("=========================================================\n");
        */

        
        // then calculate leak expr and add to hardware file 

        // finally write mv program to ostream f 


    }
}