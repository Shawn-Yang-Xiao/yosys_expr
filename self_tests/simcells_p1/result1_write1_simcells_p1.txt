
 /----------------------------------------------------------------------------\
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |  Copyright (C) 2012 - 2025  Claire Xenia Wolf <claire@yosyshq.com>         |
 |  Distributed under an ISC-like license, type "license" to see terms        |
 \----------------------------------------------------------------------------/
 Yosys 0.58+86 (git sha1 bd28a10b9, g++ 13.3.0-6ubuntu2~24.04 -fPIC -O3)

-- Executing script file `write1_simcells_p1.ys' --

1. Executing Verilog-2005 frontend: simcells_p1.v
Parsing Verilog input from `simcells_p1.v' to AST representation.
verilog frontend filename simcells_p1.v
Generating RTLIL representation for module `\$_BUF_'.
Generating RTLIL representation for module `\$_NOT_'.
Generating RTLIL representation for module `\$_AND_'.
Generating RTLIL representation for module `\$_NAND_'.
Generating RTLIL representation for module `\$_OR_'.
Generating RTLIL representation for module `\$_NOR_'.
Generating RTLIL representation for module `\$_XOR_'.
Generating RTLIL representation for module `\$_XNOR_'.
Generating RTLIL representation for module `\$_ANDNOT_'.
Generating RTLIL representation for module `\$_ORNOT_'.
Successfully finished Verilog frontend.

2. Executing MV backend.
/* Generated by Yosys_expr based on Yosys 0.58+86 (git sha1 bd28a10b9, g++ 13.3.0-6ubuntu2~24.04 -fPIC -O3) */

3. Executing Verilog-2005 frontend: simcells_p1.v
Parsing Verilog input from `simcells_p1.v' to AST representation.
verilog frontend filename simcells_p1.v
Generating RTLIL representation for module `\$_BUF_'.
Generating RTLIL representation for module `\$_NOT_'.
Generating RTLIL representation for module `\$_AND_'.
Generating RTLIL representation for module `\$_NAND_'.
Generating RTLIL representation for module `\$_OR_'.
Generating RTLIL representation for module `\$_NOR_'.
Generating RTLIL representation for module `\$_XOR_'.
Generating RTLIL representation for module `\$_XNOR_'.
Generating RTLIL representation for module `\$_ANDNOT_'.
Generating RTLIL representation for module `\$_ORNOT_'.
Successfully finished Verilog frontend.

4. Executing PROC pass (convert processes to netlists).

4.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

4.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed a total of 0 dead cases.

4.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 0 assignments to connections.

4.4. Executing PROC_INIT pass (extract init attributes).

4.5. Executing PROC_ARST pass (detect async resets in processes).

4.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.

4.7. Executing PROC_MUX pass (convert decision trees to multiplexers).

4.8. Executing PROC_DLATCH pass (convert process syncs to latches).

4.9. Executing PROC_DFF pass (convert process syncs to FFs).

4.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

4.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

4.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module \$_ORNOT_.
Optimizing module \$_ANDNOT_.
Optimizing module \$_XNOR_.
Optimizing module \$_XOR_.
Optimizing module \$_NOR_.
Optimizing module \$_OR_.
Optimizing module \$_NAND_.
Optimizing module \$_AND_.
Optimizing module \$_NOT_.
Optimizing module \$_BUF_.

5. Executing OPT_EXPR pass (perform const folding).
Optimizing module \$_ORNOT_.
Optimizing module \$_ANDNOT_.
Optimizing module \$_XNOR_.
Optimizing module \$_XOR_.
Optimizing module \$_NOR_.
Optimizing module \$_OR_.
Optimizing module \$_NAND_.
Optimizing module \$_AND_.
Optimizing module \$_NOT_.
Optimizing module \$_BUF_.

6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \$_ORNOT_..
Finding unused cells or wires in module \$_ANDNOT_..
Finding unused cells or wires in module \$_XNOR_..
Finding unused cells or wires in module \$_XOR_..
Finding unused cells or wires in module \$_NOR_..
Finding unused cells or wires in module \$_OR_..
Finding unused cells or wires in module \$_NAND_..
Finding unused cells or wires in module \$_AND_..
Finding unused cells or wires in module \$_NOT_..
Finding unused cells or wires in module \$_BUF_..
Removed 0 unused cells and 9 unused wires.
<suppressed ~9 debug messages>
cell type \$_ANDNOT_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := * wire \A wire $not$simcells_p1.v:175$25_Y; 
    false := false; 
    wire $not$simcells_p1.v:175$25_Y := ~ wire \B; 
    false := false; 
    }


cell type \$_AND_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := * wire \A wire \B; 
    false := false; 
    false := false; 
    }


cell type \$_BUF_:
    inputs: \A;
    output: \Y;
    {
    wire \Y := wire \A; 
    false := false; 
    }


cell type \$_NAND_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := ~ wire $and$simcells_p1.v:75$17_Y; 
    wire $and$simcells_p1.v:75$17_Y := * wire \A wire \B; 
    false := false; 
    false := false; 
    }


cell type \$_NOR_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := ~ wire $or$simcells_p1.v:115$20_Y; 
    wire $or$simcells_p1.v:115$20_Y := ~ (* (~ wire \A) (~ wire \B)); 
    false := false; 
    false := false; 
    }


cell type \$_NOT_:
    inputs: \A;
    output: \Y;
    {
    wire \Y := ~ wire \A; 
    false := false; 
    }


cell type \$_ORNOT_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := ~ (* (~ wire \A) (~ wire $not$simcells_p1.v:195$27_Y)); 
    false := false; 
    wire $not$simcells_p1.v:195$27_Y := ~ wire \B; 
    false := false; 
    }


cell type \$_OR_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := ~ (* (~ wire \A) (~ wire \B)); 
    false := false; 
    false := false; 
    }


cell type \$_XNOR_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := ~ wire $xor$simcells_p1.v:155$23_Y; 
    wire $xor$simcells_p1.v:155$23_Y := + wire \A wire \B; 
    false := false; 
    false := false; 
    }


cell type \$_XOR_:
    inputs: \A, \B;
    output: \Y;
    {
    wire \Y := + wire \A wire \B; 
    false := false; 
    false := false; 
    }


End of script. Logfile hash: 686c9f8e66, CPU: user 0.01s system 0.01s, MEM: 18.04 MB peak
Yosys 0.58+86 (git sha1 bd28a10b9, g++ 13.3.0-6ubuntu2~24.04 -fPIC -O3)
Time spent: 53% 2x opt_expr (0 sec), 20% 3x read_verilog (0 sec), ...
